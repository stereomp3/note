# xv6

> 下面的內容代表課程走向，大多都是貼下列的網站README，我會在程式代碼裡面多加上一些新手補充注釋
>
> https://github.com/riscv2os/riscv2os/wiki/xv6Kernel
>
> https://github.com/riscv2os/riscv2os/wiki/xv6ForkExec
>
> https://github.com/riscv2os/riscv2os/wiki/c
>
> https://github.com/riscv2os/riscv2os/wiki/xv6c2unix
>
> https://github.com/riscv2os/riscv2os/wiki/xv6CatWrite



很陽春的作業系統，不過有行程管理，有shell，基本的都有，不過大概有8000行..

執行過程: `entry.S` -> `start.c` -> `main.c` -> `proc.c`

## 啟動程式

> entry.S: 每一個核心都有用到，第一個核心當主要系統，其他核心進行排程

```assembly
# qemu -kernel loads the kernel at 0x80000000
        # and causes each CPU to jump there.
        # kernel.ld causes the following code to
        # be placed at 0x80000000.
.section .text
_entry: # 進入點被設定在 0x80000000 # 開機位置
	# set up a stack for C.
        # stack0 is declared in start.c,
        # with a 4096-byte stack per CPU.
        # sp = stack0 + (hartid * 4096)
        la sp, stack0    # 設定推疊
        li a0, 1024*4    # 每個核心堆疊大小為 1024 bytes  (多級分頁表)
	csrr a1, mhartid # 取得核心代號 hartid
        addi a1, a1, 1   # a1 = 核心代號+1
        mul a0, a0, a1   # a0 = 4096*a1 
        add sp, sp, a0   # sp = stack0 + (hartid*4096)
	# jump to start() in start.c
        call start       # 呼叫 C 語言的 start 函數
spin: # 不是作業系統的core就當排程器
        j spin           # 這裡不應該被執行，若有就卡住當機

```



> start.c: 設定時間中斷，並會透過 `w_mepc((uint64)main)` ，設定機器模式的 mret 返回點，在最後在 `asm volatile("mret")` 執行時，進入 main() 函數

```c
#include "types.h"
#include "param.h"
#include "memlayout.h"
#include "riscv.h"
#include "defs.h"

// C 語言啟動點：從 entry.S 啟動後，由 start.c 呼叫 main()
void main();
void timerinit();

// entry.S needs one stack per CPU.
__attribute__ ((aligned (16))) char stack0[4096 * NCPU];

// a scratch area per CPU for machine-mode timer interrupts.
uint64 timer_scratch[NCPU][5];

// assembly code in kernelvec.S for machine-mode timer interrupt.
extern void timervec();

// entry.S jumps here in machine mode on stack0.
void
start() // 必須先設定處理器相關參數 (CSR 暫存器)
{
  // set M Previous Privilege mode to Supervisor, for mret.
  unsigned long x = r_mstatus(); // 讓 mret 之後會進入 supervisor 模式
  x &= ~MSTATUS_MPP_MASK;
  x |= MSTATUS_MPP_S;
  w_mstatus(x);

  // set M Exception Program Counter to main, for mret.
  // requires gcc -mcmodel=medany 
  //   medany/medlow 等選項之意義請參考 -- https://www.sifive.com/blog/all-aboard-part-4-risc-v-code-models
  // mechine exception program count
  w_mepc((uint64)main); // mret 後會跳入 main

  // disable paging for now.
  w_satp(0); // 暫時不用分頁機制

  // delegate all interrupts and exceptions to supervisor mode.
  // 參考 -- https://www.five-embeddev.com/riscv-isa-manual/latest/machine.html#machine-trap-delegation-registers-medeleg-and-mideleg
  w_medeleg(0xffff); // medeleg: machine exception delegation register 全設定為 1，由 S-mode 處理 exception
  w_mideleg(0xffff); // mideleg: machine interrupt delegation register 全設定為 1，由 S-mode 處理 interrupt

  // sie 參考 -- https://www.five-embeddev.com/riscv-isa-manual/latest/supervisor.html#supervisor-interrupt-registers-sip-and-sie
  w_sie(r_sie() | SIE_SEIE | SIE_STIE | SIE_SSIE); // S-mode Interrupt-Enable
  // SEIE: supervisor-level external interrupts
  // STIE: supervisor-level timer interrupts
  // SIE_SSIE: supervisor-level software interrupts

  // ask for clock interrupts.
  timerinit(); // 設定並啟動時間中斷

  // keep each CPU's hartid in its tp register, for cpuid().
  int id = r_mhartid();
  w_tp(id); // tp 是一般暫存器，速度較快，專門用來儲存 hartid，這樣不用讀取 CSR 的 hartid

  // switch to supervisor mode and jump to main().
  asm volatile("mret");
}

// set up to receive timer interrupts in machine mode,
// which arrive at timervec in kernelvec.S,
// which turns them into software interrupts for
// devintr() in trap.c.
void
timerinit() // 設定並啟動時間中斷
{
  // each CPU has a separate source of timer interrupts.
  int id = r_mhartid();

  // ask the CLINT for a timer interrupt.
  int interval = 1000000; // cycles; about 1/10th second in qemu.
  *(uint64*)CLINT_MTIMECMP(id) = *(uint64*)CLINT_MTIME + interval; // 設定下次中斷時間

  // prepare information in scratch[] for timervec.
  // scratch[0..2] : space for timervec to save registers.
  // scratch[3] : address of CLINT MTIMECMP register.
  // scratch[4] : desired interval (in cycles) between timer interrupts.
  uint64 *scratch = &timer_scratch[id][0]; // 設定 scratch 暫存區，[0..2] 保存 a1, a2, a3 等暫存器
  scratch[3] = CLINT_MTIMECMP(id); // 放入 CLINT_MTIMECMP 到 scratch[3] 給 timervec 使用
  scratch[4] = interval;           // 放入 interval 到 scratch[4] 給 timervec 使用
  w_mscratch((uint64)scratch);     // 寫入到 msratch 暫存器

  // set the machine-mode trap handler.
  w_mtvec((uint64)timervec);       // 設定時間中斷函數 (M-mode)

  // enable machine-mode interrupts.
  w_mstatus(r_mstatus() | MSTATUS_MIE); // 啟動中斷 (M-mode)

  // enable machine-mode timer interrupts.
  w_mie(r_mie() | MIE_MTIE); // 啟動時間中斷 (M-mode)
}
```



> main.c: 進行一系列核心設定動作

```c
#include "types.h"
#include "param.h"
#include "memlayout.h"
#include "riscv.h"
#include "defs.h"

volatile static int started = 0;

// start() jumps here in supervisor mode on all CPUs.
void
main() // kernel 的主程式，啟動核心並載入第一個 init 使用者行程
{
  if(cpuid() == 0){  // 第 0 的 hart 用來跑核心
    consoleinit();   // 準備好 console
    printfinit();    // 準備好 printf
    printf("\n");
    printf("xv6 kernel is booting\n");
    printf("\n");
    kinit();         // physical page allocator // 準備好實體分頁
    kvminit();       // create kernel page table // 準備好核心分頁表
    kvminithart();   // turn on paging // 啟動分頁表
    procinit();      // process table // 準備好行程表
    trapinit();      // trap vectors  // 設定好 trap 中斷
    trapinithart();  // install kernel trap vector  // 安裝核心的中斷向量
    plicinit();      // set up interrupt controller // 設定中斷控制器
    plicinithart();  // ask PLIC for device interrupts // 設定裝置中斷
    binit();         // buffer cache // 檔案系統: 緩衝快取
    iinit();         // inode cache  // 檔案系統: inode快取 (inode是type，指Linux檔案類型)
    fileinit();      // file table   // 檔案系統: 設置檔案表
    virtio_disk_init(); // emulated hard disk // 檔案系統: 設置 virtio 虛擬硬碟
    userinit();      // first user process // 啟動第一個使用者行程 init
    __sync_synchronize();
    started = 1;     // 啟動已完成
  } else {  // 其他的 hart(CPU core) 用來跑一般程式
    while(started == 0)
      ;
    __sync_synchronize();
    printf("hart %d starting\n", cpuid());
    kvminithart();    // turn on paging // 啟動分頁表
    trapinithart();   // install kernel trap vector  // 安裝核心的中斷向量
    plicinithart();   // ask PLIC for device interrupts // 設定裝置中斷
  }

  scheduler(); // 進入排程系統 (無窮迴圈)  // 排程器處理三個核心
}

```



每個核心都會進入 scheduler() 函數，將處理器核心 (hart) 交給行程表中第一個可執行 (RUNNABLE) 的行程。

> proc.c

```c
// Per-CPU process scheduler. // 每個 CPU 都有自己的排程器
// Each CPU calls scheduler() after setting itself up.
// Scheduler never returns.  It loops, doing:
//  - choose a process to run.
//  - swtch to start running that process.
//  - eventually that process transfers control
//    via swtch back to the scheduler.
void
scheduler(void)
{
  struct proc *p;
  struct cpu *c = mycpu(); // 取得本核心的處理器資訊
  
  c->proc = 0;
  for(;;){
    // Avoid deadlock by ensuring that devices can interrupt.
    intr_on();
    // 當回到本排程器時，挑選下一個 RUNNABLE 的行程來執行。
    for(p = proc; p < &proc[NPROC]; p++) {
      acquire(&p->lock);  // 防止同時行程表，使用spin lock
      if(p->state == RUNNABLE) {
        // Switch to chosen process.  It is the process's job
        // to release its lock and then reacquire it
        // before jumping back to us.
        p->state = RUNNING;
        c->proc = p;
        swtch(&c->context, &p->context); // 切換給該行程執行。

        // Process is done running for now.
        // It should have changed its p->state before coming back.
        c->proc = 0;
      }
      release(&p->lock);  // 釋放行程表，讓其他人可以對變數做修改
    }
  }
}
```

透過 `swtch(&c->context, &p->context)` 函數，控制權會從 scheduler 手上，轉交給行程 p。

> swtch.S

```asm
# Context switch (內文切換，C 語言呼叫方法如下)
#
#   void swtch(struct context *old, struct context *new);
# 
# Save current registers in old. Load from new.	
# 問題：為何不用儲存全部暫存器？ 
# 猜測：這應該看編譯器會用到那些暫存器當臨時變數，像是參數 a0..a7 應該就不用保存。
.globl swtch
swtch: # 內文切換，保存舊暫存器群，切換到新暫存器群
        sd ra, 0(a0)
        sd sp, 8(a0)
        sd s0, 16(a0)
        sd s1, 24(a0)
        sd s2, 32(a0)
        sd s3, 40(a0)
        sd s4, 48(a0)
        sd s5, 56(a0)
        sd s6, 64(a0)
        sd s7, 72(a0)
        sd s8, 80(a0)
        sd s9, 88(a0)
        sd s10, 96(a0)
        sd s11, 104(a0)

        ld ra, 0(a1)
        ld sp, 8(a1)
        ld s0, 16(a1)
        ld s1, 24(a1)
        ld s2, 32(a1)
        ld s3, 40(a1)
        ld s4, 48(a1)
        ld s5, 56(a1)
        ld s6, 64(a1)
        ld s7, 72(a1)
        ld s8, 80(a1)
        ld s9, 88(a1)
        ld s10, 96(a1)
        ld s11, 104(a1)
        
        ret
```



## 行程控制

> trap.c: 處理行程控制
>
> 1. 該行程透過系統呼叫主動交還控制權。
> 2. 硬體引發外部中斷，於是交還控制權給作業系統。
> 3. 時間片段用盡，透過時間中斷強制取回控制權。

```c
//
// handle an interrupt, exception, or system call from user space.
// called from trampoline.S
//
void
usertrap(void) // 使用者中斷 (自陷 trap)
{
  int which_dev = 0;

  if((r_sstatus() & SSTATUS_SPP) != 0) // 是否來自 user mode ?
    panic("usertrap: not from user mode");

  // send interrupts and exceptions to kerneltrap(),
  // since we're now in the kernel.
  w_stvec((uint64)kernelvec); // 設定中斷向量為 kernelvec ，這樣才能從 usermode 跳回 kernel mode.

  struct proc *p = myproc(); // 取得目前 process
  
  // save user program counter.
  p->trapframe->epc = r_sepc(); // 儲存程式計數器 sepc  // super user pocess count
  
  if(r_scause() == 8){ // 如果是系統呼叫  // 軟體中斷
    // system call

    if(p->killed) // 如果行程已經被殺死，則呼叫 exit(-1) 離開
      exit(-1);

    // sepc points to the ecall instruction,
    // but we want to return to the next instruction.
    p->trapframe->epc += 4; // 得儲存 ecall 的下一個指令

    // an interrupt will change sstatus &c registers,
    // so don't enable until done with those registers.
    intr_on(); // 允許裝置中斷

    syscall(); // 執行系統呼叫 
  } else if((which_dev = devintr()) != 0){ // 如果是裝置中斷，呼叫 devintr() 處理之。
    // ok
  } else { // 否則為錯誤，設定 p->killed 並結束本行程
    printf("usertrap(): unexpected scause %p pid=%d\n", r_scause(), p->pid);
    printf("            sepc=%p stval=%p\n", r_sepc(), r_stval());
    p->killed = 1;
  }

  if(p->killed)
    exit(-1);

  // give up the CPU if this is a timer interrupt.
  if(which_dev == 2) // 如果是時間中斷，禮讓給其他 process
    yield();

  usertrapret(); // 從 usertrap 返回
}
```

第一種管道: 系統呼叫

> syscall.c

```c
static uint64 (*syscalls[])(void) = {
[SYS_fork]    sys_fork,
[SYS_exit]    sys_exit,
[SYS_wait]    sys_wait,
[SYS_pipe]    sys_pipe,
[SYS_read]    sys_read,
[SYS_kill]    sys_kill,
[SYS_exec]    sys_exec,
[SYS_fstat]   sys_fstat,
[SYS_chdir]   sys_chdir,
[SYS_dup]     sys_dup,
[SYS_getpid]  sys_getpid,
[SYS_sbrk]    sys_sbrk,
[SYS_sleep]   sys_sleep,
[SYS_uptime]  sys_uptime,
[SYS_open]    sys_open,
[SYS_write]   sys_write,
[SYS_mknod]   sys_mknod,
[SYS_unlink]  sys_unlink,
[SYS_link]    sys_link,
[SYS_mkdir]   sys_mkdir,
[SYS_close]   sys_close,
};

void
syscall(void) // 系統呼叫
{
  int num;
  struct proc *p = myproc();

  num = p->trapframe->a7; // a7 中放了系統呼叫代號
  if(num > 0 && num < NELEM(syscalls) && syscalls[num]) { // 系統呼叫代號正確
    p->trapframe->a0 = syscalls[num](); // 呼叫該系統呼叫 // 呼叫函式
  } else { // 系統呼叫代號錯誤
    printf("%d %s: unknown sys call %d\n",
            p->pid, p->name, num);
    p->trapframe->a0 = -1;
  }
}
```

這些系統呼叫是由 usys.pl 程式產生出來的組合語言：

> usys.pl: 為了產生編譯程式碼usys.S，使用這個的方法可以讓程式碼變短

```perl
#!/usr/bin/perl -w

# Generate usys.S, the stubs for syscalls.

print "# generated by usys.pl - do not edit\n";

print "#include \"kernel/syscall.h\"\n";

sub entry {
    my $name = shift;
    print ".global $name\n";
    print "${name}:\n";
    print " li a7, SYS_${name}\n";
    print " ecall\n";
    print " ret\n";
}
	
entry("fork");
entry("exit");
...
```



> usys.S: usys.pl產生出來的程式碼

```asm
# generated by usys.pl - do not edit
#include "kernel/syscall.h"
.global fork
fork:
 li a7, SYS_fork
 ecall
 ret
.global exit
exit:
 li a7, SYS_exit
 ecall   # 會跳到 uservec
 ret
# ...
```



> trampoline.S: 裡面有uservec 組合語言程式

```asm
uservec:# 進入使用者中斷    
	#
        # trap.c sets stvec to point here, so
        # traps from user space start here,
        # in supervisor mode, but with a
        # user page table.
        #
        # sscratch points to where the process's p->trapframe is
        # mapped into user space, at TRAPFRAME.
        #
        # ------------ 以下是儲存 user process 暫存器的程式段落 ------------------
	# swap a0 and sscratch    # 原本 sscratch = p->trapframe, 現在兩者交換 swap(sscratch, a0)
        # so that a0 is TRAPFRAME # 所以現在 a0 = p->trapframe
        csrrw a0, sscratch, a0 

        # save the user registers in TRAPFRAME # 儲存所有 user process 的暫存器到 p->trapframe
        sd ra, 40(a0)
        sd sp, 48(a0)
        sd gp, 56(a0)
        sd tp, 64(a0)
        sd t0, 72(a0) # 連臨時暫存器 t0-t6, 參數暫存器 a0-a7 都必須存起來
        sd t1, 80(a0)
        sd t2, 88(a0)
        sd s0, 96(a0)
        sd s1, 104(a0)
        sd a1, 120(a0)
        sd a2, 128(a0)
        sd a3, 136(a0)
        sd a4, 144(a0)
        sd a5, 152(a0)
        sd a6, 160(a0)
        sd a7, 168(a0)
        sd s2, 176(a0)
        sd s3, 184(a0)
        sd s4, 192(a0)
        sd s5, 200(a0)
        sd s6, 208(a0)
        sd s7, 216(a0)
        sd s8, 224(a0)
        sd s9, 232(a0)
        sd s10, 240(a0)
        sd s11, 248(a0)
        sd t3, 256(a0)
        sd t4, 264(a0)
        sd t5, 272(a0)
        sd t6, 280(a0)

	# save the user a0 in p->trapframe->a0
        csrr t0, sscratch # sscratch 就是剛剛和 a0 交換的，所以就是 p->trapframe
        sd t0, 112(a0)    # 將 p->trapframe 存入 112(p->trapframe)
        # ------- 以下是恢復核心暫存器的處理程式 --------------------
        # restore kernel stack pointer from p->trapframe->kernel_sp
        ld sp, 8(a0)      # 恢復堆疊

        # make tp hold the current hartid, from p->trapframe->kernel_hartid
        ld tp, 32(a0)     # tp = kernel.hartid

        # load the address of usertrap(), p->trapframe->kernel_trap
        ld t0, 16(a0)     # t0 = usertrap

        # restore kernel page table from p->trapframe->kernel_satp
        ld t1, 0(a0)
        csrw satp, t1     # 恢復核心的分頁表
        sfence.vma zero, zero # 清除 TLB 讓緩存失效

        # a0 is no longer valid, since the kernel page
        # table does not specially map p->tf.

        # jump to usertrap(), which does not return
        jr t0             # 跳到 usertrap()
```



第二種管道: 裝置中斷

> trap.c

```c
// check if it's an external interrupt or software interrupt,
// and handle it.
// returns 2 if timer interrupt,
// 1 if other device,
// 0 if not recognized.
int
devintr() // 裝置中斷
{
  uint64 scause = r_scause();

  if((scause & 0x8000000000000000L) &&
     (scause & 0xff) == 9){ // 1. 硬體外部中斷
    // this is a supervisor external interrupt, via PLIC.

    // irq indicates which device interrupted.
    int irq = plic_claim();

    if(irq == UART0_IRQ){ // UART 中斷
      uartintr();
    } else if(irq == VIRTIO0_IRQ){ // 磁碟中斷
      virtio_disk_intr();
    } else if(irq){
      printf("unexpected interrupt irq=%d\n", irq);
    }

    // the PLIC allows each device to raise at most one
    // interrupt at a time; tell the PLIC the device is
    // now allowed to interrupt again.
    if(irq)
      plic_complete(irq); // 可以允許再次中斷了。

    return 1;
  } else if(scause == 0x8000000000000001L){ // 2. 時間中斷
    // software interrupt from a machine-mode timer interrupt,
    // forwarded by timervec in kernelvec.S.

    if(cpuid() == 0){
      clockintr();
    }
    
    // acknowledge the software interrupt by clearing
    // the SSIP bit in sip.
    w_sip(r_sip() & ~2); // 註：sip 是 software interrupt-pending

    return 2;
  } else {
    return 0;
  }
}
```



第三種管道: 時間中斷

> trap.c

```c
void
clockintr() // 時間中斷
{
  acquire(&tickslock);
  ticks++;  // 目前的時間標籤，會一直往上增加
  wakeup(&ticks); // 喚醒等待時間中斷的行程
  release(&tickslock);
}
```



```c
// Wake up all processes sleeping on chan.
// Must be called without any p->lock.
void
wakeup(void *chan)
{
  struct proc *p;

  for(p = proc; p < &proc[NPROC]; p++) {
    if(p != myproc()){
      acquire(&p->lock);
      if(p->state == SLEEPING && p->chan == chan) {
        p->state = RUNNABLE;  // 做完事情後，把等待時間中斷的行程喚醒
      }
      release(&p->lock);
    }
  }
}
```



> proc.c

```c
// Give up the CPU for one scheduling round.
void
yield(void)  // 讓出控制權
{
  struct proc *p = myproc();
  acquire(&p->lock);
  p->state = RUNNABLE;  // 設定為可以運行
  sched();   // 進行排程
  release(&p->lock);
}
```

yield() 會呼叫 sched() ，進而透過 swtch(&p->context, &mycpu()->context) 交還控制權給核心。

```c
// Switch to scheduler.  Must hold only p->lock
// and have changed proc->state. Saves and restores
// intena because intena is a property of this
// kernel thread, not this CPU. It should
// be proc->intena and proc->noff, but that would
// break in the few places where a lock is held but
// there's no process.
void
sched(void)
{
  int intena;
  struct proc *p = myproc();

  if(!holding(&p->lock))
    panic("sched p->lock");
  if(mycpu()->noff != 1)
    panic("sched locks");
  if(p->state == RUNNING)
    panic("sched running");
  if(intr_get())
    panic("sched interruptible");

  intena = mycpu()->intena;
  swtch(&p->context, &mycpu()->context);  // 回去跑schedler()
  mycpu()->intena = intena;
}
```

在 usertrap() 的最後一行，會透過 usertrapret() 將控制權交回給使用者行程 (程式碼如下)，這樣就能在該行程完成之後，恢復行程的執行了。

> trap.c: 裡面有分頁表和彈跳床，可以讓記憶體運作到相對的位置，然後呼叫函數

```c
//
// return to user space // 切換回使用者空間
//
void
usertrapret(void)
{
  struct proc *p = myproc();

  // we're about to switch the destination of traps from
  // kerneltrap() to usertrap(), so turn off interrupts until
  // we're back in user space, where usertrap() is correct.
  intr_off(); // 禁止裝置中斷

  // send syscalls, interrupts, and exceptions to trampoline.S
  w_stvec(TRAMPOLINE + (uservec - trampoline)); // 設定中斷向量為 uservec ，這樣才能從 kernel mode 跳回 user mode.
  // 保存該行程的 kernel 相關暫存器，以便下次要再進入核心時使用
  // set up trapframe values that uservec will need when
  // the process next re-enters the kernel.
  p->trapframe->kernel_satp = r_satp();         // kernel page table (核心分頁表)
  p->trapframe->kernel_sp = p->kstack + PGSIZE; // process's kernel stack (核心堆疊)
  p->trapframe->kernel_trap = (uint64)usertrap; // 中斷位址
  p->trapframe->kernel_hartid = r_tp();         // hartid for cpuid() (核心代號)

  // set up the registers that trampoline.S's sret will use
  // to get to user space.
  // 回復到使用者模式
  // set S Previous Privilege mode to User.
  unsigned long x = r_sstatus();
  x &= ~SSTATUS_SPP; // clear SPP to 0 for user mode
  x |= SSTATUS_SPIE; // enable interrupts in user mode
  w_sstatus(x);

  // set S Exception Program Counter to the saved user pc.
  w_sepc(p->trapframe->epc); // 設定 sepc 準備返回

  // tell trampoline.S the user page table to switch to.
  uint64 satp = MAKE_SATP(p->pagetable); // 切換回使用者分頁表

  // jump to trampoline.S at the top of memory, which 
  // switches to the user page table, restores user registers,
  // and switches to user mode with sret.
  // #define TRAMPOLINE (MAXVA - PGSIZE) // 最後一頁是彈跳床 TRAMPOLINE
  // TRAMPOLINE是彈跳床放在最後一頁的最上面，放在memlayout.h
  // 使用者的核心程式的最後一頁就是userret
  uint64 fn = TRAMPOLINE + (userret - trampoline); // 呼叫 trampoline.S 的 userret 以切換回使用者行程。
  ((void (*)(uint64,uint64))fn)(TRAPFRAME, satp);  // 呼叫userret函數給他參數TRAPFRAME、satp
}
```



> tampoline.S

```asm
.globl userret
userret:# 從使用者中斷返回
        # userret(TRAPFRAME, pagetable)
        # switch from kernel to user.
        # usertrapret() calls here.
        # a0: TRAPFRAME, in user page table.
        # a1: user page table, for satp.

        # switch to the user page table.
        # 每一個行程的分頁表都不一樣，所以要切換
        # 切回使用者分頁表，分頁表一切換，整個對應的func就會不一樣了
        csrw satp, a1              
        sfence.vma zero, zero
        # ------- 以下是恢復使用者暫存器的處理程式 --------------------
        # put the saved user a0 in sscratch, so we
        # can swap it with our a0 (TRAPFRAME) in the last step.
        ld t0, 112(a0)
        csrw sscratch, t0

        # restore all but a0 from TRAPFRAME
        ld ra, 40(a0)
        ld sp, 48(a0)
        ld gp, 56(a0)
        ld tp, 64(a0)
        ld t0, 72(a0)
        ld t1, 80(a0)
        ld t2, 88(a0)
        ld s0, 96(a0)
        ld s1, 104(a0)
        ld a1, 120(a0)
        ld a2, 128(a0)
        ld a3, 136(a0)
        ld a4, 144(a0)
        ld a5, 152(a0)
        ld a6, 160(a0)
        ld a7, 168(a0)
        ld s2, 176(a0)
        ld s3, 184(a0)
        ld s4, 192(a0)
        ld s5, 200(a0)
        ld s6, 208(a0)
        ld s7, 216(a0)
        ld s8, 224(a0)
        ld s9, 232(a0)
        ld s10, 240(a0)
        ld s11, 248(a0)
        ld t3, 256(a0)
        ld t4, 264(a0)
        ld t5, 272(a0)
        ld t6, 280(a0)

	# restore user a0, and save TRAPFRAME in sscratch
        csrrw a0, sscratch, a0
        
        # return to user mode and user pc. // sret 會取回 user pc 然後繼續執行該使用者行程
        # usertrapret() set up sstatus and sepc.
        sret
```









////

必須注意的是，那些中斷的處理程式，都是在作業系統一開始時就設定好的，舉例而言，時間中斷強制取回的方式，是由以下程式中的 `w_mtvec((uint64)timervec)` 指令所設定的。(而且同時會設定時間片段的大小，一旦時間用盡就會引發中斷)

> start.c

```c
// set up to receive timer interrupts in machine mode,
// which arrive at timervec in kernelvec.S,
// which turns them into software interrupts for
// devintr() in trap.c.
void
timerinit()
{
  // each CPU has a separate source of timer interrupts.
  int id = r_mhartid();

  // ask the CLINT for a timer interrupt.
  int interval = 1000000; // cycles; about 1/10th second in qemu.
  *(uint64*)CLINT_MTIMECMP(id) = *(uint64*)CLINT_MTIME + interval;

  // prepare information in scratch[] for timervec.
  // scratch[0..2] : space for timervec to save registers.
  // scratch[3] : address of CLINT MTIMECMP register.
  // scratch[4] : desired interval (in cycles) between timer interrupts.
  uint64 *scratch = &timer_scratch[id][0];
  scratch[3] = CLINT_MTIMECMP(id);
  scratch[4] = interval;
  w_mscratch((uint64)scratch);

  // set the machine-mode trap handler.
  w_mtvec((uint64)timervec);

  // enable machine-mode interrupts.
  w_mstatus(r_mstatus() | MSTATUS_MIE);

  // enable machine-mode timer interrupts.
  w_mie(r_mie() | MIE_MTIE);
}
```

當時間片段用盡時，會觸發 timervec() 函數，

> kernelvec.S

```asm
        #
        # machine-mode timer interrupt. 機器模式的時間中斷
        #
.globl timervec
.align 4
timervec:
        # start.c has set up the memory that mscratch points to:
        # scratch[0,8,16] : register save area.
        # scratch[24] : address of CLINT's MTIMECMP register.
        # scratch[32] : desired interval between interrupts.
        
        csrrw a0, mscratch, a0  # 儲存到暫存區
        sd a1, 0(a0)
        sd a2, 8(a0)
        sd a3, 16(a0)

        # schedule the next timer interrupt # 設定下一次中斷時間
        # by adding interval to mtimecmp.
        ld a1, 24(a0) # CLINT_MTIMECMP(hart)
        ld a2, 32(a0) # interval
        ld a3, 0(a1)
        add a3, a3, a2
        sd a3, 0(a1)

        # raise a supervisor software interrupt. 
        # 引發特權軟體中斷，跳到 kernelvec=>kerneltrap()
        li a1, 2
        csrw sip, a1

        ld a3, 16(a0)  # 從暫存區取回暫存器
        ld a2, 8(a0)
        ld a1, 0(a0)
        csrrw a0, mscratch, a0

        mret
```

以上 timervec 當中的 `csrw sip, a1` 指令，會引發核心中斷

```c
        # raise a supervisor software interrupt. 
        # 引發核心中斷，跳到 kernelvec=>kerneltrap()
        li a1, 2
        csrw sip, a1
```

於是程式跳到 kernelvec() 中

```asm
	#
        # interrupts and exceptions while in supervisor
        # mode come here.
        #
        # push all registers, call kerneltrap(), restore, return.
        #
.globl kerneltrap
.globl kernelvec
.align 4
kernelvec:
        # make room to save registers. # 分配堆疊以儲存暫存器
        addi sp, sp, -256

        # save the registers.
        sd ra, 0(sp)
        sd sp, 8(sp)
        sd gp, 16(sp)
        sd tp, 24(sp)
        sd t0, 32(sp)
        sd t1, 40(sp)
        sd t2, 48(sp)
        sd s0, 56(sp)
        sd s1, 64(sp)
        sd a0, 72(sp)
        sd a1, 80(sp)
        sd a2, 88(sp)
        sd a3, 96(sp)
        sd a4, 104(sp)
        sd a5, 112(sp)
        sd a6, 120(sp)
        sd a7, 128(sp)
        sd s2, 136(sp)
        sd s3, 144(sp)
        sd s4, 152(sp)
        sd s5, 160(sp)
        sd s6, 168(sp)
        sd s7, 176(sp)
        sd s8, 184(sp)
        sd s9, 192(sp)
        sd s10, 200(sp)
        sd s11, 208(sp)
        sd t3, 216(sp)
        sd t4, 224(sp)
        sd t5, 232(sp)
        sd t6, 240(sp)

	# call the C trap handler in trap.c # 呼叫 C 語言的 kerneltrap() 函數。
        call kerneltrap

        # restore registers. # 恢復暫存器
        ld ra, 0(sp)
        ld sp, 8(sp)
        ld gp, 16(sp)
        # not this, in case we moved CPUs: ld tp, 24(sp)
        ld t0, 32(sp)
        ld t1, 40(sp)
        ld t2, 48(sp)
        ld s0, 56(sp)
        ld s1, 64(sp)
        ld a0, 72(sp)
        ld a1, 80(sp)
        ld a2, 88(sp)
        ld a3, 96(sp)
        ld a4, 104(sp)
        ld a5, 112(sp)
        ld a6, 120(sp)
        ld a7, 128(sp)
        ld s2, 136(sp)
        ld s3, 144(sp)
        ld s4, 152(sp)
        ld s5, 160(sp)
        ld s6, 168(sp)
        ld s7, 176(sp)
        ld s8, 184(sp)
        ld s9, 192(sp)
        ld s10, 200(sp)
        ld s11, 208(sp)
        ld t3, 216(sp)
        ld t4, 224(sp)
        ld t5, 232(sp)
        ld t6, 240(sp)

        addi sp, sp, 256 # 恢復堆疊指標

        # return to whatever we were doing in the kernel.
        sret
```

kernelvec() 又用 call kerneltrap 呼叫 C 語言的中斷處理函數 kerneltrap()。

```c
// interrupts and exceptions from kernel code go here via kernelvec,
// on whatever the current kernel stack is.
void 
kerneltrap()
{
  int which_dev = 0;
  uint64 sepc = r_sepc();
  uint64 sstatus = r_sstatus();
  uint64 scause = r_scause();
  
  if((sstatus & SSTATUS_SPP) == 0)
    panic("kerneltrap: not from supervisor mode");
  if(intr_get() != 0)
    panic("kerneltrap: interrupts enabled");

  if((which_dev = devintr()) == 0){ // 1. 裝置中斷
    printf("scause %p\n", scause);
    printf("sepc=%p stval=%p\n", r_sepc(), r_stval());
    panic("kerneltrap");
  }

  // give up the CPU if this is a timer interrupt.
  if(which_dev == 2 && myproc() != 0 && myproc()->state == RUNNING)  // 1. 時間中斷，禮讓給別人
    yield(); // 註：時間中斷對 user mode 與 kernel mode 都是有效的，都必須禮讓給別人。

  // the yield() may have caused some traps to occur,
  // so restore trap registers for use by kernelvec.S's sepc instruction.
  w_sepc(sepc);
  w_sstatus(sstatus);
}
```

kerneltrap() 會根據是哪一種中斷分別處理。

1. 如果是裝置中斷，那麼交給 devintr() 函數。
2. 如果是時間中斷，則呼叫 yield() 強制交還控制權。

kerneltrap() 和 usertrap() 稍有差異，因為 kerneltrap() 當中不需要處理軟體中斷 (系統呼叫) 的狀況。



當核心準備好一切，進入排程系統 scheduler() 時，已經設定好了《軟體中斷，裝置中斷與時間中斷》，因此以下的 scheduler() 函數才能正常的執行排程工作。

> proc.c: 第一個被排程的程式是init，後面其他程式再陸續被排程

```c
// Per-CPU process scheduler.
// Each CPU calls scheduler() after setting itself up.
// Scheduler never returns.  It loops, doing:
//  - choose a process to run.
//  - swtch to start running that process.
//  - eventually that process transfers control
//    via swtch back to the scheduler.
void
scheduler(void)
{
  struct proc *p;
  struct cpu *c = mycpu();
  
  c->proc = 0;
  for(;;){
    // Avoid deadlock by ensuring that devices can interrupt.
    intr_on();

    for(p = proc; p < &proc[NPROC]; p++) {
      acquire(&p->lock);
      if(p->state == RUNNABLE) {
        // Switch to chosen process.  It is the process's job
        // to release its lock and then reacquire it
        // before jumping back to us.
        p->state = RUNNING;
        c->proc = p;
        swtch(&c->context, &p->context);

        // Process is done running for now.
        // It should have changed its p->state before coming back.
        c->proc = 0;
      }
      release(&p->lock);
    }
  }
}
```



///////////////////

## 行程初始化

main() 中呼叫的 userinit() 函數定義如下：

> proc.c

```c
// Set up first user process.
void
userinit(void)
{
  struct proc *p;  // proccess的結構

  p = allocproc();  // 設定行程
  initproc = p;
  
  // allocate one user page and copy init's instructions
  // and data into it.
  uvminit(p->pagetable, initcode, sizeof(initcode));
  p->sz = PGSIZE;

  // prepare for the very first "return" from kernel to user.
  p->trapframe->epc = 0;      // user program counter
  p->trapframe->sp = PGSIZE;  // user stack pointer

  safestrcpy(p->name, "initcode", sizeof(p->name));
  p->cwd = namei("/");

  p->state = RUNNABLE;

  release(&p->lock);
}
```



而其中的 initcode 這個變數，則是一段奇特的十六進位碼如下：

```c
// a user program that calls exec("/init")
// od -t xC initcode
uchar initcode[] = {
  0x17, 0x05, 0x00, 0x00, 0x13, 0x05, 0x45, 0x02,
  0x97, 0x05, 0x00, 0x00, 0x93, 0x85, 0x35, 0x02,
  0x93, 0x08, 0x70, 0x00, 0x73, 0x00, 0x00, 0x00,
  0x93, 0x08, 0x20, 0x00, 0x73, 0x00, 0x00, 0x00,
  0xef, 0xf0, 0x9f, 0xff, 0x2f, 0x69, 0x6e, 0x69,
  0x74, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00
};
```

上面那堆 `uchar initcode[] = { 0x17, 0x05, 0x00 ...` 到底是甚麼呢？

其實就是下列組合語言的機器碼，被直接寫在 initcode[] 陣列裡面了。

user/initcode.S

```c
# Initial process that execs /init.
# This code runs in user space.

#include "syscall.h"

# exec(init, argv)
.globl start
start:
        la a0, init
        la a1, argv
        li a7, SYS_exec
        ecall

# for(;;) exit();
exit:
        li a7, SYS_exit
        ecall
        jal exit

# char init[] = "/init\0";
init:
  .string "/init\0"

# char *argv[] = { init, 0 };
.p2align 2
argv:
  .long init
  .long 0
```

就是透過上面這個奇怪的方式， xv6 把 initcode 強行塞入到分頁表中，然後呼叫 SYS_exec 把 init 這個執行檔載入到記憶體裡，成為第一個被執行的使用者 (user mode) 程式。



## 設定虛擬機

> vm.c

```c
void
uvminit(pagetable_t pagetable, uchar *src, uint sz)
{
  char *mem;

  if(sz >= PGSIZE)
    panic("inituvm: more than a page");
  mem = kalloc();
  memset(mem, 0, PGSIZE);  // 設定記憶體
  mappages(pagetable, 0, PGSIZE, (uint64)mem, PTE_W|PTE_R|PTE_X|PTE_U);
  memmove(mem, src, sz);   // 把src的帶把丟到mem裡面
}
```

```c
// Create PTEs for virtual addresses starting at va that refer to
// physical addresses starting at pa. va and size might not
// be page-aligned. Returns 0 on success, -1 if walk() couldn't
// allocate a needed page-table page.
int
mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm)
{
  uint64 a, last;
  pte_t *pte;
  // 映射範圍：從 va 到 va+size
  a = PGROUNDDOWN(va); // 第一頁的頁號
  last = PGROUNDDOWN(va + size - 1); // 最後一頁的頁號
  for(;;){
    if((pte = walk(pagetable, a, 1)) == 0) // 找出頁 a 對應的 pte，若不存在則創造一個可用空頁 (因 alloc=1)
      return -1;
    if(*pte & PTE_V)
      panic("remap");
    *pte = PA2PTE(pa) | perm | PTE_V;
    if(a == last) // 如果已經到了最後一頁，則完成並離開
      break;
    a += PGSIZE;
    pa += PGSIZE;
  }
  return 0;
}

```







## init

終於我們可以仔細看看 init 執行檔的原始碼了，這個 user mode 天字第一號的 init.c 程式了。

user/init.c

```c
// init: The initial user-level program

#include "kernel/types.h"
#include "kernel/stat.h"
#include "kernel/spinlock.h"
#include "kernel/sleeplock.h"
#include "kernel/fs.h"
#include "kernel/file.h"
#include "user/user.h"
#include "kernel/fcntl.h"

char *argv[] = { "sh", 0 };

int
main(void)
{
  int pid, wpid;

  if(open("console", O_RDWR) < 0){ // 開啟 console 裝置
    mknod("console", CONSOLE, 0); // 若開啟失敗，則創建該裝置為第 0 號檔案 (stdin)。
    open("console", O_RDWR);
  }
  dup(0);  // stdout // 複製 stdin 到 stdout
  dup(0);  // stderr // 複製 stdin 到 stderr

  for(;;){
    printf("init: starting sh\n");
    pid = fork(); // fork 出一個子行程
    if(pid < 0){
      printf("init: fork failed\n");
      exit(1);
    }
    if(pid == 0){  // child
      exec("sh", argv); // 將該子行程替換為 sh (shell)
      printf("init: exec sh failed\n");
      exit(1);
    }

    for(;;){ // 等候 shell 行程退出，之後會再啟動另一個 shell
      // this call to wait() returns if the shell exits,
      // or if a parentless process exits.
      wpid = wait((int *) 0);
      if(wpid == pid){
        // the shell exited; restart it.
        break;
      } else if(wpid < 0){ 
        printf("init: wait returned an error\n");
        exit(1);
      } else {
        // it was a parentless process; do nothing.
      }
    }
  }
}
```

這個 init.c 程式才是本文想要討論的主角，特別是裡面的 fork() 與 exec()

熟悉 linux 系統程式的人應該都知道， fork() 函數是讓該行程 (process)《一分為二》，原本的程式還在，但是多出了一個 child。(也就是 parent 還在，但生出了一個 child)。

所以當 pid=fork() 被執行後，若 fork() 的傳回值 pid == 0，就代表該行程為 child，於是 init.c 讓子行程載入 sh (shell)

```c
    pid = fork(); // fork 出一個子行程
    // ...
    if(pid == 0){
      exec("sh", argv); // 將該子行程替換為 sh (shell)
      printf("init: exec sh failed\n");
      exit(1);
    }
```

init 的主要任務就是載入 shell，而且讓 shell 不斷執行 (就算跳出後也繼續創出下一個 shell 執行)。

本文所要探討的重點就是， fork() 和 exec() 兩個函數到底是怎麼實作的，然後藉此觀察整個 xv6 的行程管理系統，到底是怎麼運作的。

## fork

fork() 函數定義在 proc.c 裡面，其中的 `np = allocproc()` 會分配一個新的子行程，然後透過 `uvmcopy(p->pagetable, np->pagetable, p->sz)` 這行指令複製其分頁表給子行程。

> proc.c

```c
// Create a new process, copying the parent.
// Sets up child kernel stack to return as if from fork() system call.
int
fork(void)
{
  int i, pid;
  struct proc *np;
  struct proc *p = myproc();

  // Allocate process.
  if((np = allocproc()) == 0){ // 分配新的子行程
    return -1;
  }

  // Copy user memory from parent to child.
  if(uvmcopy(p->pagetable, np->pagetable, p->sz) < 0){ // 將分頁表複製給子行程。
    freeproc(np);
    release(&np->lock);
    return -1;
  }
  np->sz = p->sz; // 子行程大小和父行程相同

  // copy saved user registers.
  *(np->trapframe) = *(p->trapframe); // 暫存器也相同

  // Cause fork to return 0 in the child.
  np->trapframe->a0 = 0; // 子行程的 fork 傳回值應為 0 (注意，父行程傳回值沒修改)

  // increment reference counts on open file descriptors.
  for(i = 0; i < NOFILE; i++)
    if(p->ofile[i])
      np->ofile[i] = filedup(p->ofile[i]); // 複製檔案表，舊的行程表複製給新的行程表
  np->cwd = idup(p->cwd); // 複製 cwd 目前目錄 

  safestrcpy(np->name, p->name, sizeof(p->name)); // 複製名稱

  pid = np->pid;

  release(&np->lock);

  acquire(&wait_lock);
  np->parent = p;
  release(&wait_lock);

  acquire(&np->lock);
  np->state = RUNNABLE; // 設定子行程為 RUNNABLE
  release(&np->lock);

  return pid;
}
```

透過 fork() 函數，我們可以創建一個和父行程幾乎一模一樣的子行程。

然後再透過 exec()，我們就可以載入任何想載入的執行檔 (ELF 格式)了，讓我們看看 exec() 的原始碼。

kernel/exec.c

```c
#include "types.h"
#include "param.h"
#include "memlayout.h"
#include "riscv.h"
#include "spinlock.h"
#include "proc.h"
#include "defs.h"
#include "elf.h"

static int loadseg(pde_t *pgdir, uint64 addr, struct inode *ip, uint offset, uint sz);

int
exec(char *path, char **argv)
{
  char *s, *last;
  int i, off;
  uint64 argc, sz = 0, sp, ustack[MAXARG+1], stackbase;
  struct elfhdr elf;
  struct inode *ip;
  struct proghdr ph;
  pagetable_t pagetable = 0, oldpagetable;
  struct proc *p = myproc();

  begin_op();

  if((ip = namei(path)) == 0){ // 取得 path ELF 檔對應的 inode ptr (ip)
    end_op();
    return -1;
  }
  ilock(ip);

  // Check ELF header，inode是xv6裡面檔案系統設定的節點
  if(readi(ip, 0, (uint64)&elf, 0, sizeof(elf)) != sizeof(elf)) // 讀取該 inode (Linux檔案)
    goto bad;
  if(elf.magic != ELF_MAGIC) // 若不是 ELF 則失敗
    goto bad;

  if((pagetable = proc_pagetable(p)) == 0) // 分配頁表
    goto bad;

  // Load program into memory.
  for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
    if(readi(ip, 0, (uint64)&ph, off, sizeof(ph)) != sizeof(ph))
      goto bad;
    if(ph.type != ELF_PROG_LOAD)
      continue;
    if(ph.memsz < ph.filesz)
      goto bad;
    if(ph.vaddr + ph.memsz < ph.vaddr)
      goto bad;
    uint64 sz1;
    if((sz1 = uvmalloc(pagetable, sz, ph.vaddr + ph.memsz)) == 0) // 為每個ELF段分配內存
      goto bad;
    sz = sz1;
    if(ph.vaddr % PGSIZE != 0)
      goto bad;
    if(loadseg(pagetable, ph.vaddr, ip, ph.off, ph.filesz) < 0) // 把每個段加載到內存中 (loadseg用walkaddr找到分配的內存的物理地址，在這個地址上寫入ELF段的每一頁，用readi從文件中讀取)
      goto bad; 
  }
  iunlockput(ip);
  end_op();
  ip = 0;

  p = myproc();
  uint64 oldsz = p->sz;

  // Allocate two pages at the next page boundary. 為何分配兩頁？第二個是堆疊，那第一個幹嘛用？
  // Use the second as the user stack.  答：第一個是不可訪問頁，當堆疊溢位時會觸發錯誤中斷。
  sz = PGROUNDUP(sz);
  uint64 sz1;
  if((sz1 = uvmalloc(pagetable, sz, sz + 2*PGSIZE)) == 0)
    goto bad;
  sz = sz1;
  uvmclear(pagetable, sz-2*PGSIZE);
  sp = sz;
  stackbase = sp - PGSIZE;

  // Push argument strings, prepare rest of stack in ustack. 在堆疊中推入 argv 字串
  for(argc = 0; argv[argc]; argc++) {
    if(argc >= MAXARG)
      goto bad;
    sp -= strlen(argv[argc]) + 1;
    sp -= sp % 16; // riscv sp must be 16-byte aligned
    if(sp < stackbase)
      goto bad;
    if(copyout(pagetable, sp, argv[argc], strlen(argv[argc]) + 1) < 0) // 複製失敗就離開
      goto bad;
    ustack[argc] = sp;
  }
  ustack[argc] = 0;

  // push the array of argv[] pointers. 推入 argv 的指標
  sp -= (argc+1) * sizeof(uint64);
  sp -= sp % 16;
  if(sp < stackbase)
    goto bad;
  if(copyout(pagetable, sp, (char *)ustack, (argc+1)*sizeof(uint64)) < 0)
    goto bad;

  // arguments to user main(argc, argv)
  // argc is returned via the system call return
  // value, which goes in a0.
  p->trapframe->a1 = sp; // 設定 a1=argv

  // Save program name for debugging.
  for(last=s=path; *s; s++)
    if(*s == '/')
      last = s+1;
  safestrcpy(p->name, last, sizeof(p->name));
    
  // Commit to the user image.
  oldpagetable = p->pagetable; // 註：oldpagetable 指向 fork 時的 process，現在已經換成新 process 了。
  p->pagetable = pagetable;
  p->sz = sz;
  p->trapframe->epc = elf.entry;  // initial program counter = main (進入點為 main)
  p->trapframe->sp = sp; // initial stack pointer
  proc_freepagetable(oldpagetable, oldsz);

  return argc; // this ends up in a0, the first argument to main(argc, argv)

 bad:
  if(pagetable)
    proc_freepagetable(pagetable, sz);
  if(ip){
    iunlockput(ip);
    end_op();
  }
  return -1;
}
```

exec() 函數的程式碼很長，首先是用 `ip = namei(path)` 取得 ELF 格式執行檔的 inode，接著用 `readi(ip, 0, (uint64)&elf, 0, sizeof(elf)` 將 《ELF 檔頭》讀進來，放在 elf 變數裏。

接著是把每個分段逐一載入到記憶體中，以組合《程式段、資料段、BSS段》成為完整的機器碼。

```c
  // Load program into memory.
  for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
    if(readi(ip, 0, (uint64)&ph, off, sizeof(ph)) != sizeof(ph))
      goto bad;
    if(ph.type != ELF_PROG_LOAD)
      continue;
    if(ph.memsz < ph.filesz)
      goto bad;
    if(ph.vaddr + ph.memsz < ph.vaddr)
      goto bad;
    uint64 sz1;
    if((sz1 = uvmalloc(pagetable, sz, ph.vaddr + ph.memsz)) == 0) // 為每個ELF段分配內存
      goto bad;
    sz = sz1;
    if(ph.vaddr % PGSIZE != 0)
      goto bad;
    if(loadseg(pagetable, ph.vaddr, ip, ph.off, ph.filesz) < 0) // 把每個段加載到內存中 (loadseg用walkaddr找到分配的內存的物理地址，在這個地址上寫入ELF段的每一頁，用readi從文件中讀取)
      goto bad; 
  }
```

剩下的就是建構 argv 等參數，還有新行程的分頁表等等，這樣就完成了換掉該行程執行檔的功能，於是行程就《改頭換面》了。

所以 init.c 當中的下列段落，才能創建出 shell (sh) 行程。

```c
    pid = fork(); // fork 出一個子行程
    // ...
    if(pid == 0){
      exec("sh", argv); // 將該子行程替換為 sh (shell)
      printf("init: exec sh failed\n");
      exit(1);
    }
```

shell 會接受使用者的輸入命令，並且執行該命令，而這些動作，則又是靠一連串的 fork() + exec() 所達成的，以下是 sh 的原始程式碼之重要部分。

```c
int
main(void)
{
  static char buf[100];
  int fd;

  // Ensure that three file descriptors are open.
  while((fd = open("console", O_RDWR)) >= 0){
    if(fd >= 3){
      close(fd);
      break;
    }
  }

  // Read and run input commands.
  while(getcmd(buf, sizeof(buf)) >= 0){
    if(buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' '){
      // Chdir must be called by the parent, not the child.
      buf[strlen(buf)-1] = 0;  // chop \n
      if(chdir(buf+3) < 0)
        fprintf(2, "cannot cd %s\n", buf+3);
      continue;
    }
    if(fork1() == 0)
      runcmd(parsecmd(buf));
    wait(0);
  }
  exit(0);
}

// Execute cmd.  Never returns.
void
runcmd(struct cmd *cmd)
{
  int p[2];
  struct backcmd *bcmd;
  struct execcmd *ecmd;
  struct listcmd *lcmd;
  struct pipecmd *pcmd;
  struct redircmd *rcmd;

  if(cmd == 0)
    exit(1);

  switch(cmd->type){
  default:
    panic("runcmd");

  case EXEC:
    ecmd = (struct execcmd*)cmd;
    if(ecmd->argv[0] == 0)
      exit(1);
    exec(ecmd->argv[0], ecmd->argv);
    fprintf(2, "exec %s failed\n", ecmd->argv[0]);
    break;

  case REDIR:
    rcmd = (struct redircmd*)cmd;
    close(rcmd->fd);
    if(open(rcmd->file, rcmd->mode) < 0){
      fprintf(2, "open %s failed\n", rcmd->file);
      exit(1);
    }
    runcmd(rcmd->cmd);
    break;

  case LIST:
    lcmd = (struct listcmd*)cmd;
    if(fork1() == 0)
      runcmd(lcmd->left);
    wait(0);
    runcmd(lcmd->right);
    break;

  case PIPE:
    pcmd = (struct pipecmd*)cmd;
    if(pipe(p) < 0)
      panic("pipe");
    if(fork1() == 0){
      close(1);
      dup(p[1]);
      close(p[0]);
      close(p[1]);
      runcmd(pcmd->left);
    }
    if(fork1() == 0){
      close(0);
      dup(p[0]);
      close(p[0]);
      close(p[1]);
      runcmd(pcmd->right);
    }
    close(p[0]);
    close(p[1]);
    wait(0);
    wait(0);
    break;

  case BACK:
    bcmd = (struct backcmd*)cmd;
    if(fork1() == 0)
      runcmd(bcmd->cmd);
    break;
  }
  exit(0);
}

int
fork1(void)  // 做fork，fork失敗進入緊張模式，程式掛掉
{
  int pid;

  pid = fork();
  if(pid == -1)
    panic("fork");
  return pid;
}
```

其中的 fork1() 呼叫了 fork()，而 runcmd() 的下列段落則用了 exec() 去載入執行某 ELF 執行檔。

```c
  case EXEC:
    ecmd = (struct execcmd*)cmd;
    if(ecmd->argv[0] == 0)
      exit(1);
    exec(ecmd->argv[0], ecmd->argv);
    fprintf(2, "exec %s failed\n", ecmd->argv[0]);c
    break;
```

於是透過 xv6 提供的 fork(), exec() 等函數，我們所寫的程式都可以被編譯為 ELF 執行檔之後，由 fork() + exec() 來載入執行了！



//////////////////////////////////

# xv6: 理解檔案表 -- 從 cat.c 的 write() 指令開始追蹤

xv6 作業系統雖然 kernel 只有八千行，但是要理解其運作原理，需要一些背景知識。

為了串起這些背景知識，我們從一個 cat.c 的檔案顯示範例開始講起，並追蹤其運作原理。

透過這個案例，您將會理解 xv6 作業系統的《檔案系統 / 系統呼叫 / 中斷 / 鎖》 等機制。

現在就讓我們從 cat.c 開始出發。

## cat 指令

在安裝好 RISC-V 工具鏈之後，您可以用 make qemu 開始執行 xv6。

```sh
user@DESKTOP-96FRN6B MINGW64 /d/pmedia/陳鍾誠/課程/系統程式/10-riscv/04-xv6os/xv6
$ make qemu
gcc -Werror -Wall -I. -o mkfs/mkfs mkfs/mkfs.c
mkfs/mkfs fs.img README user/_cat user/_echo user/_forktest user/_grep user/_init user/_kill user/_ln user/_ls user/_mkdir user/_rm user/_sh user/_stressfs user/_usertests user/_grind user/_wc user/_zombie
nmeta 46 (boot, super, log blocks 30 inode blocks 13, bitmap blocks 1) blocks 954 total 1000
balloc: first 593 blocks have been allocated
balloc: write bitmap block at sector 45
qemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 256M -smp 3 -nographic -drive file=fs.img,if=none,format=raw,id=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0  

xv6 kernel is booting

hart 2 starting
hart 1 starting
init: starting sh

$ ls
.              1 1 1024
..             1 1 1024
README         2 2 2102
cat            2 3 23960
echo           2 4 22792
forktest       2 5 13128
grep           2 6 27280
init           2 7 23928
kill           2 8 22760
ln             2 9 22752
ls             2 10 26168
mkdir          2 11 22888
rm             2 12 22872
sh             2 13 41824
stressfs       2 14 23792
usertests      2 15 151208
grind          2 16 38024
wc             2 17 25056
zombie         2 18 22288
console        3 19 0
```

接著讓我們用 cat README 將該檔案顯示在畫面上。

```sh
$ cat README
xv6 is a re-implementation of Dennis Ritchie's and Ken Thompson's Unix
Version 6 (v6).  xv6 loosely follows the structure and style of v6,
but is implemented for a modern RISC-V multiprocessor using ANSI C.

ACKNOWLEDGMENTS

xv6 is inspired by John Lions's Commentary on UNIX 6th Edition (Peer
to Peer Communications; ISBN: 1-57398-013-7; 1st edition (June 14,
2000)). See also https://pdos.csail.mit.edu/6.828/, which
provides pointers to on-line resources for v6.

The following people have made contributions: Russ Cox (context switching,
locking), Cliff Frey (MP), Xiao Yu (MP), Nickolai Zeldovich, and Austin
Clements.

We are also grateful for the bug reports and patches contributed by
Silas Boyd-Wickizer, Anton Burtsev, Dan Cross, Cody Cutler, Mike CAT,
Tej Chajed, Asami Doi, eyalz800, , Nelson Elhage, Saar Ettinger, Alice
Ferrazzi, Nathaniel Filardo, Peter Froehlich, Yakir Goaron,Shivam
Handa, Bryan Henry, jaichenhengjie, Jim Huang, Alexander Kapshuk,
Anders Kaseorg, kehao95, Wolfgang Keller, Jonathan Kimmitt, Eddie
Kohler, Austin Liew, Imbar Marinescu, Yandong Mao, Matan Shabtay,
Hitoshi Mitake, Carmi Merimovich, Mark Morrissey, mtasm, Joel Nider,
Greg Price, Ayan Shafqat, Eldar Sehayek, Yongming Shen, Fumiya
Shigemitsu, Takahiro, Cam Tenny, tyfkda, Rafael Ubal, Warren Toomey,
Stephen Tu, Pablo Ventura, Xi Wang, Keiichi Watanabe, Nicolas
Wolovick, wxdao, Grant Wu, Jindong Zhang, Icenowy Zheng, and Zou Chang
Wei.

The code in the files that constitute xv6 is
Copyright 2006-2020 Frans Kaashoek, Robert Morris, and Russ Cox.

ERROR REPORTS

Please send errors and suggestions to Frans Kaashoek and Robert Morris
(kaashoek,rtm@mit.edu). The main purpose of xv6 is as a teaching
operating system for MIT's 6.S081, so we are more interested in
simplifications and clarifications than new features.

BUILDING AND RUNNING XV6

You will need a RISC-V "newlib" tool chain from
https://github.com/riscv/riscv-gnu-toolchain, and qemu compiled for
riscv64-softmmu. Once they are installed, and in your shell
search path, you can run "make qemu".
```

## cat.c

對於已經熟悉 linux 系統程式設計的人，應該很容易看懂以下的 cat.c 原始碼！

user/cat.c

```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"

char buf[512];

void
cat(int fd)
{
  int n;

  while((n = read(fd, buf, sizeof(buf))) > 0) {
    if (write(1, buf, n) != n) {
      fprintf(2, "cat: write error\n");
      exit(1);
    }
  }
  if(n < 0){
    fprintf(2, "cat: read error\n");
    exit(1);
  }
}

int
main(int argc, char *argv[])
{
  int fd, i;

  if(argc <= 1){
    cat(0);
    exit(0);
  }

  for(i = 1; i < argc; i++){
    // fd:0 stdin、fd:1 stdout、fd:2 stderr
    if((fd = open(argv[i], 0)) < 0){  // fd 通常都從 3 開始
      fprintf(2, "cat: cannot open %s\n", argv[i]);
      exit(1);
    }
    cat(fd);
    close(fd);
  }
  exit(0);
}
```

UNIX 設計的一個核心理念是，一切皆檔案，所以《由鍵盤和螢幕所組成的終端機 terminal 也是檔案》。

對於 xv6 而言，由於沒有掛上螢幕，所以採用 uart 和《宿主機》溝通，因此其終端機介面為《宿主機的終端機》。

UNIX 的檔案系統有個《檔案表》，其中標準輸入 stdin 被放在第 0 格，標準輸出 stdout 被放在第 1 格，標準錯誤 stderr 被放在第 2 格。

下圖顯示了《檔案表》的結構。

![img](https://github.com/riscv2os/riscv2os/wiki/img/fs.png)

於是當我們用 `write(1, buf, n)` 輸出到 1 (stdout) 時，buf 內容會顯示在終端機上。

xv6 的檔案相關結構定義在 file.h 當中，讓我們追蹤一下原始碼。

kernel/file.h

```c
struct file {  // 檔案表
  enum { FD_NONE, FD_PIPE, FD_INODE, FD_DEVICE } type;//類型: 無、管道、檔案、裝置
  int ref; // reference count
  char readable;
  char writable;
  struct pipe *pipe; // FD_PIPE
  struct inode *ip;  // FD_INODE and FD_DEVICE
  uint off;          // FD_INODE
  short major;       // FD_DEVICE
};

// 一些主要次要屬性
#define major(dev)  ((dev) >> 16 & 0xFFFF)
#define minor(dev)  ((dev) & 0xFFFF)
#define	mkdev(m,n)  ((uint)((m)<<16| (n)))

// in-memory copy of an inode
struct inode {
  uint dev;           // Device number
  uint inum;          // Inode number
  int ref;            // Reference count
  struct sleeplock lock; // protects everything below here
  int valid;          // inode has been read from disk?

  short type;         // copy of disk inode
  short major;
  short minor;
  short nlink;
  uint size;
  uint addrs[NDIRECT+1];
};

// map major device number to device functions.
struct devsw {
  int (*read)(int, uint64, int);
  int (*write)(int, uint64, int);
};

extern struct devsw devsw[];

#define CONSOLE 1   // 定義第一個裝置 console
```

xv6 的檔案表則是宣告在 file.c 當中，以下是其中的部分原始碼。

kernel/file.c

```c
struct devsw devsw[NDEV];
struct {
  struct spinlock lock;    // 在整理檔案必須鎖起來，不然會有競爭情況
  struct file file[NFILE];  // 檔案表
} ftable;

void
fileinit(void)
{
  initlock(&ftable.lock, "ftable");
}

// Allocate a file structure.
struct file*
filealloc(void)
{
  struct file *f;

  acquire(&ftable.lock);
  for(f = ftable.file; f < ftable.file + NFILE; f++){
    if(f->ref == 0){  // 找出第一個沒有被用的，然後分配出去
      f->ref = 1;
      release(&ftable.lock);
      return f;
    }
  }
  release(&ftable.lock);
  return 0;
}
```

而 open, read, write, close 這些函數，是定義在 user/usys.S 中的系統呼叫，會透過 ecall 去呼叫對應的系統函數。

user/usys.S

```asm
# generated by usys.pl - do not edit
#include "kernel/syscall.h"
.global fork
fork:
 li a7, SYS_fork
 ecall
 ret
.global exit
exit:
 li a7, SYS_exit
 ecall
 ret
.global wait
wait:
 li a7, SYS_wait
 ecall
 ret
.global pipe
pipe:
 li a7, SYS_pipe
 ecall
 ret
.global read
read:
 li a7, SYS_read  # 用read呼叫SYS_read
 ecall
 ret
.global write
write:
 li a7, SYS_write
 ecall
 ret
.global close
close:
 li a7, SYS_close
 ecall
 ret
.global kill
kill:
 li a7, SYS_kill
 ecall
 ret
.global exec
exec:
 li a7, SYS_exec
 ecall
 ret
.global open
open:
 li a7, SYS_open
 ecall
 ret
.global mknod
mknod:
 li a7, SYS_mknod
 ecall
 ret
.global unlink
unlink:
 li a7, SYS_unlink
 ecall
 ret
.global fstat
fstat:
 li a7, SYS_fstat
 ecall
 ret
.global link
link:
 li a7, SYS_link
 ecall
 ret
.global mkdir
mkdir:
 li a7, SYS_mkdir
 ecall
 ret
.global chdir
chdir:
 li a7, SYS_chdir
 ecall
 ret
.global dup
dup:
 li a7, SYS_dup
 ecall
 ret
.global getpid
getpid:
 li a7, SYS_getpid
 ecall
 ret
.global sbrk
sbrk:
 li a7, SYS_sbrk
 ecall
 ret
.global sleep
sleep:
 li a7, SYS_sleep
 ecall
 ret
.global uptime
uptime:
 li a7, SYS_uptime
 ecall
 ret
```

當我們呼叫 `write(1, buf, n)` 時，會執行下列組合語言指令

```asm
write:
 li a7, SYS_write
 ecall
 ret
```

其中的 ecall 會產生《軟體中斷》，然後透過下列的中斷表，會跳到 sys_write 去執行。

```c
static uint64 (*syscalls[])(void) = {
[SYS_fork]    sys_fork,
[SYS_exit]    sys_exit,
[SYS_wait]    sys_wait,
[SYS_pipe]    sys_pipe,
[SYS_read]    sys_read,
[SYS_kill]    sys_kill,
[SYS_exec]    sys_exec,
[SYS_fstat]   sys_fstat,
[SYS_chdir]   sys_chdir,
[SYS_dup]     sys_dup,
[SYS_getpid]  sys_getpid,
[SYS_sbrk]    sys_sbrk,
[SYS_sleep]   sys_sleep,
[SYS_uptime]  sys_uptime,
[SYS_open]    sys_open,
[SYS_write]   sys_write,
[SYS_mknod]   sys_mknod,
[SYS_unlink]  sys_unlink,
[SYS_link]    sys_link,
[SYS_mkdir]   sys_mkdir,
[SYS_close]   sys_close,
};

void
syscall(void)
{
  int num;
  struct proc *p = myproc();

  num = p->trapframe->a7;
  if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
    p->trapframe->a0 = syscalls[num]();  // 中斷函數
  } else {
    printf("%d %s: unknown sys call %d\n",
            p->pid, p->name, num);
    p->trapframe->a0 = -1;
  }
}
```

而 sys_write 的原始碼放在 sysfile.c 中，在此會呼叫 file.c 中定義的 filewrite() 函數。

kernel/sysfile.c: 跟檔案相關的都放在裡面

```c
uint64
sys_write(void)
{
  struct file *f;
  int n;
  uint64 p;

  if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argaddr(1, &p) < 0)
    return -1;

  return filewrite(f, p, n);  // 呼叫對應檔案表，叫出裝置做write的動作
}
```

filewrite() 函數則會呼叫檔案表 ftable 中對應裝置 devsw 裏的 write 函數。

讓我們再看一遍 file.h 與 file.c 中的關鍵程式碼

kernel/file.h

```c
struct file {
  enum { FD_NONE, FD_PIPE, FD_INODE, FD_DEVICE } type;//類型: 無、管道、檔案、裝置
  int ref; // reference count
  char readable;
  char writable;
  struct pipe *pipe; // FD_PIPE
  struct inode *ip;  // FD_INODE and FD_DEVICE
  uint off;          // FD_INODE
  short major;       // FD_DEVICE
};

#define major(dev)  ((dev) >> 16 & 0xFFFF)
#define minor(dev)  ((dev) & 0xFFFF)
#define	mkdev(m,n)  ((uint)((m)<<16| (n)))

// in-memory copy of an inode
struct inode {  // 系統檔案的結構(真正的ㄉㄤ)
  uint dev;           // Device number
  uint inum;          // Inode number
  int ref;            // Reference count
  struct sleeplock lock; // protects everything below here
  int valid;          // inode has been read from disk?

  short type;         // copy of disk inode
  short major;
  short minor;
  short nlink;
  uint size;
  uint addrs[NDIRECT+1];
};

// map major device number to device functions.
struct devsw {
  int (*read)(int, uint64, int);
  int (*write)(int, uint64, int);
};

extern struct devsw devsw[];

#define CONSOLE 1
```

kernel/file.c

```c
struct devsw devsw[NDEV];
struct {
  struct spinlock lock;
  struct file file[NFILE];
} ftable;
```

再重新釐清一遍，於是當我們呼叫 `write(1, buf, n)` 時，會執行 usys.S 中的 write，

user/usys.S

```asm
write:
 li a7, SYS_write
 ecall
 ret
```

然後透過軟體中斷跳到系統呼叫 sys_write

kernel/sysfile.c

```c
uint64
sys_write(void)
{
  struct file *f;
  int n;
  uint64 p;

  if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argaddr(1, &p) < 0)
    return -1;

  return filewrite(f, p, n);
}
```

於是進入了 file.c 中的 filewrite()

kernel/file.c

```c
// Write to file f.
// addr is a user virtual address.
int
filewrite(struct file *f, uint64 addr, int n)
{
  int r, ret = 0;

  if(f->writable == 0)
    return -1;

  if(f->type == FD_PIPE){
    ret = pipewrite(f->pipe, addr, n);
  } else if(f->type == FD_DEVICE){
    if(f->major < 0 || f->major >= NDEV || !devsw[f->major].write)
      return -1;
    ret = devsw[f->major].write(1, addr, n);
  } else if(f->type == FD_INODE){
    // write a few blocks at a time to avoid exceeding
    // the maximum log transaction size, including
    // i-node, indirect block, allocation blocks,
    // and 2 blocks of slop for non-aligned writes.
    // this really belongs lower down, since writei()
    // might be writing a device like the console.
    int max = ((MAXOPBLOCKS-1-1-2) / 2) * BSIZE;
    int i = 0;
    while(i < n){
      int n1 = n - i;
      if(n1 > max)
        n1 = max;

      begin_op();
      ilock(f->ip);
      if ((r = writei(f->ip, 1, addr + i, f->off, n1)) > 0)
        f->off += r;
      iunlock(f->ip);
      end_op();

      if(r != n1){
        // error from writei
        break;
      }
      i += r;
    }
    ret = (i == n ? n : -1);
  } else {
    panic("filewrite");
  }

  return ret;
}
```

由於 ftable.file[1].major 指定的裝置為 console，所以 `devsw[f->major].write(1, addr, n)` 會執行 `consolewrite(1, addr, n)`。

kernel/console.c

```c
void
consoleinit(void)
{
  initlock(&cons.lock, "cons");

  uartinit();

  // connect read and write system calls
  // to consoleread and consolewrite.
  devsw[CONSOLE].read = consoleread; // CONSOLE 在 kernel/file.h 定義為 1
  devsw[CONSOLE].write = consolewrite;
}
```

然後 `consolewrite()` 會連續呼叫 n 次的 `uartputc(c)` 去輸出該字串到《宿主機的終端機》中

```c
//
// user write()s to the console go here.
//
int
consolewrite(int user_src, uint64 src, int n)
{
  int i;

  for(i = 0; i < n; i++){
    char c;
    if(either_copyin(&c, user_src, src+i, 1) == -1)
      break;
    uartputc(c);
  }

  return i;
}
```

所以 cat.c 才能透過 `write(1, buf, n)` 把讀到的檔案內容顯示在畫面上。

而其中 uartputc(c) 是透過記憶體映射的方式，將字元傳送給宿主機的，程式碼如下：

```c
// add a character to the output buffer and tell the
// UART to start sending if it isn't already.
// blocks if the output buffer is full.
// because it may block, it can't be called
// from interrupts; it's only suitable for use
// by write().
void
uartputc(int c)
{
  acquire(&uart_tx_lock);

  if(panicked){
    for(;;)
      ;
  }

  while(1){
    if(uart_tx_w == uart_tx_r + UART_TX_BUF_SIZE){
      // buffer is full.
      // wait for uartstart() to open up space in the buffer.
      sleep(&uart_tx_r, &uart_tx_lock);
    } else {
      uart_tx_buf[uart_tx_w % UART_TX_BUF_SIZE] = c;
      uart_tx_w += 1;  // 設定要寫的字元多一個
      uartstart();   // 輸出字元
      release(&uart_tx_lock);
      return;
    }
  }
}
//...
// if the UART is idle, and a character is waiting
// in the transmit buffer, send it.
// caller must hold uart_tx_lock.
// called from both the top- and bottom-half.
void
uartstart()
{
  while(1){
    if(uart_tx_w == uart_tx_r){
      // transmit buffer is empty.
      return;
    }
    
    if((ReadReg(LSR) & LSR_TX_IDLE) == 0){
      // the UART transmit holding register is full,
      // so we cannot give it another byte.
      // it will interrupt when it's ready for a new byte.
      return;
    }
    
    int c = uart_tx_buf[uart_tx_r % UART_TX_BUF_SIZE];
    uart_tx_r += 1;
    
    // maybe uartputc() is waiting for space in the buffer.
    wakeup(&uart_tx_r);
    
    WriteReg(THR, c);
  }
}
```


